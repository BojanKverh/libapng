#pragma once

#include "crc.h"
#include "info.h"

#include <optional>

#include <QByteArray>
#include <QSet>

class QFile;

namespace png {

/**
 * @brief The ChunkName enum Denotes the validity of the chunk name
 */
enum class ChunkName {
    ecnInvalid,
    ecnPNG,
    ecnAPNG
};

/**
 * @brief The Chunk class This struct holds data about an individual chunk
 */
struct Chunk {
    quint32 m_uiLength;
    QByteArray m_baName;
    QByteArray m_baContent;
    QByteArray m_baCRC;

    /**
     * @brief size Returns the size of the chunk
     * @return chunk size in [bytes]
     */
    quint32 size() const { return 4 + m_baName.size() + m_baContent.size() + m_baCRC.size(); }
};
/**
 * @brief The BasePNG class This class contains some basic PNG definitions
 */
class __declspec(dllexport) Base
{
public:
  /**
   * @brief info Returns the information object about the latest import command
   * @return Object, containing information about the latest import command
   */
  Info info() const { return m_info; }

protected:
  /**
   * @brief convert Converts the 32-bit value into QByteArray
   * @param uiValue Value to convert
   * @return Generated byte array
   */
    QByteArray convert(quint32 uiValue) const;
    /**
   * @brief convert Converts the first four bytes of array into quint32
   * @param rba Byte array to convert
   * @return calculated value
   */
    quint32 convert(const QByteArray& rba) const;
    /**
     * @brief crc Returns the chunk CRC
     * @param rChunk Reference to the chunk, for which the CRC will be calculated
     * @return Calculated crc
     */
    quint32 crc(const Chunk& rChunk) const;
    /**
   * @brief readChunk Reads one chunk of data
   * @param rba Byte array to read from
   * @param riOffset Reference to the offset variable, which denotes the start of reading
   * @return read chunk data or an empty value, if the chunk could not be read
   */
    std::optional<Chunk> readChunk(const QByteArray& rba, quint32 &riOffset);
    /**
     * @brief writeChunk Appends the chunk into
     * @param rba Byte array, where the chunk will be appended to
     * @param rChunk Reference to the chunk to be appended
     * @param bCalcCRC Indicates, whether the CRC has to be recalculated
     */
    void writeChunk(QByteArray& rba, const Chunk& rChunk, bool bCalcCRC = false) const;
    /**
     * @brief writeChunk Writes the chunk directly to file
     * @param rF Reference to the file to write into
     * @param rChunk Reference to the chunk to write into the file
     * @param bCalcCRC Indicates, whether the CRC has to be recalculated
     */
    void writeChunk(QFile& rF, const Chunk& rChunk, bool bCalcCRC = false) const;
    /**
     * @brief actl Returns the ACTL chunk
     * @param iCount Number of frames
     * @param iRepeat Number of animation repeatitions
     * @return ACTL chunk
     */
    Chunk actl(quint32 iCount, quint32 iRepeat = 0U) const;
    /**
     * @brief fctl Returns the FCTL chunk
     * @param i FCTL index
     * @param iW Frame width in [pixels]
     * @param iH Frame height in [pixels]
     * @param iFPS Frames per second rate
     * @param iX Horizontal offset in pixels
     * @param iY Vertical offset in pixels
     * @param iDispose Dispose method indicator. Possible values are 0, 1 and 2
     * @param iBlend Blend method indicator. Possible values are 0 and 1
     * @return FCTL chunk
     */
    Chunk fctl(int i, int iW, int iH, int iFPS, int iX, int iY, int iDispose = 0, int iBlend = 0) const;
    /**
     * @brief iend Returns the IEND chunk
     * @return IEND chunk
     */
    Chunk iend() const;
    /**
     * @brief validity Checks if the name of the chunk is valid
     * @param rba Chunk name to check
     * @return ChunkName::ecnPNG, if the chunk name is a valid PNG chunk name,
     *   ChunkName::ecnAPNG, if the chunk name is a valid APNG (and not PNG!) chunk name and
     *   ChunkName::ecnInvalid otherwise.
     */
    ChunkName validity(const QByteArray& rba) const;
    /**
     * @brief reset Resets the info object
     */
    virtual void reset();

protected:
    CRC m_crc;
    Info m_info;

    const QByteArray m_cbaSig  = QByteArray::fromHex("89504E470D0A1A0A");
    const QByteArray m_cbaIDAT = QByteArray::fromHex("49444154");
    const QByteArray m_cbaIHDR = QByteArray::fromHex("49484452");
    const QByteArray m_cbaTEXT = QByteArray::fromHex("74455874");
    const QByteArray m_cbaACTL = QByteArray::fromHex("6163544C");
    const QByteArray m_cbaFCTL = QByteArray::fromHex("6663544C");
    const QByteArray m_cbaFDAT = QByteArray::fromHex("66644154");
    const QByteArray m_cbaIEND = QByteArray::fromHex("49454E44");

    const quint32 m_cuiLibPngLimit = 8192U;

    /**
     * @brief m_qslValidChunks Set of valid PNG chunk (except IDAT) names obtained from
     * https://www.w3.org/TR/PNG-Chunks.html
     */
    const QSet<QByteArray> m_csetValidPngChunks = {
        m_cbaIHDR,                       // IHDR
        m_cbaIDAT,                       // IDAT
        QByteArray::fromHex("504C5445"), // PLTE
        m_cbaIEND,                       // IEND
        QByteArray::fromHex("624B4744"), // bKGD
        QByteArray::fromHex("6348524D"), // cHRM
        QByteArray::fromHex("67414D41"), // gAMA
        QByteArray::fromHex("68495354"), // hIST
        QByteArray::fromHex("70485973"), // pHYs
        QByteArray::fromHex("73424954"), // sBIT
        m_cbaTEXT,                       // tEXt
        QByteArray::fromHex("74494D45"), // tIME
        QByteArray::fromHex("74524E53"), // tRNS
        QByteArray::fromHex("7A545874")  // zTXt
    };
    /**
     * @brief m_qslValidApngChunks Set of valid APNG chunk names (except fdAT), that can only be
     * found in APNG files, but not in static PNG
     */
    const QSet<QByteArray> m_csetValidApngChunks = {
        m_cbaACTL,                       // acTL
        m_cbaFCTL,                       // fcTL
        m_cbaFDAT                        // fdAT
    };
};

}
